- 数据生产层：

  有ETL，数据仓库，自己写的一些日志处理的工具

  （最底层，数据产生层，主要是从日志中获取用户行为数据）

- 数据存储：

  mysql，redis，ES

- 召回层（离线计算结果）：

  - item-base CF（itemcf中商品的相似度是根据用户来计算的，在我们的平台中，用户数量是多于商品数量的）
  - 冷启动推荐结果（由于新注册的用户我们只能获取到注册省份）
  - 基于内容推荐（用户商品矩阵和商品特征矩阵相乘，就得到了，用户偏好矩阵，也就得到了每个用户的偏好向量，这个偏好是用户对每一项属性值的偏好，加入说国家这个特征，共有10个属性值，那么把用户对这10个属性值的偏好评分加起来在除以10，那么就得到了，用户对国家这个特征的偏好。）
  - 矩阵分解（将用户商品矩阵分解成为用户偏好矩阵和商品特征矩阵）
  - 基于用户交互行为：利用用户最近产生交互的商品，不同的交互行为有着不同的权重，这个权重用于相似度计算的权重，比如说，下单，权重是1，浏览权重是0.5，找到这些商品的相似商品后，按距离排序输出前N个商品。
  - 利用用户搜索数据，分词后，获取用户当前感兴趣的特征那个

- 结果融合&规则过滤

  - 主要是业务规则
  - 添加随机产品 以增加推荐新颖性

- 重排序

  - LR（用户特征：用户画像，上下文：时间，是否节假日，设备 商品特征：）
  - DeepFM
    - 优化
    - 改变精度 如：tf.float32改为tf.float16
    - 减少全连接层数
    - 减少embedding_size

刚才基于内容获取到了用户偏好，那么当为用户形成推荐结果的时候，为用户展示其最感兴趣的特征



缓存机制，装饰器实现：

​	存储用户推荐结果